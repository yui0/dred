// Copyright (C) 2017 David Reid. See included LICENSE file.

// QUICK NOTES
//
// General
// - dr_gui is a low-level GUI system that works on generic objects referred to as "elements".
// - An element is the most basic unit in dr_gui. It contains basic information about it's layout and hierarchy.
// - Controls can be used as the building blocks for more complex controls such as list boxes and scrollbars.
// - The layout of elements use floats instead of integers. The rationale for this is that it makes it easier to do certain
//   layout arithmetic. For example, if you want to evenly distribute 3 elements across a fixed area, the integer based
//   arithmetic can cause rounding errors which cause the elements to not sit flush against the area. By using float-based
//   arithmetic we can avoid that particular issue.
//
// Hierarchy
// - An element can have a parent and any number of children. If an element does not have a parent, it is referred to as the
//   top-level element.
// - When an element is deleted, it's children will be deleted as well.
// - Top-level elements do not have siblings.
//
// Event Handling
// - The application must notify dr_gui of application-generated events such as key strokes and mouse movements. These are
//   referred to as inbound events. An event that is generated by dr_gui are referred to as outbound events.
// - Inbound events are used to generate outbound events. For example, a mouse-move inbound event will generate an outbound
//   mouse-move event, and perhaps a mouse leave/enter pair.
// - Outbound events are posted and handled immediately. A call to dred_gui_post_inbound_event_*() will not return until all of
//   the outbound events it generates have been handled.
// - Inbound events are not thread safe, however an application is free to post an inbound event from any thread so long as
//   it does it's own synchronization.
// - Inbound events will typically specify the relevant top-level element and let dr_gui do the relevant processing required
//   to generate the appropriate outbound events. For example, the mouse-move event will be specified with respect to the top-
//   level element, but dr_gui will determine the exact child element that the mouse moved on and thus should receive the
//   relevant outbound mouse-move event.
// - There are some special events that are handled differently to normal events. The best example is the paint events. The
//   paint event is only called from dred_control_draw().
// - Key press/release events are only ever posted to the element that has the keyboard capture/focus which is set with
//   dred_gui_capture_keyboard(). Thus, when posting an inbound key event, a top-level element is not required when posting
//   those events. The relevant context is still required, however.
//
// Global Outbound Event Handling
// - At times dr_gui will need to notify the host application in order for certain functionality to work properly. For example.
//   when the mouse is captured it won't work 100% correct unless the host application has a chance to capture the mouse against
//   the container window. Because dr_gui has no notion of a window system it relies on the host application to handle this
//   properly.
// - A global outbound event handler should be implemented for each of the following events:
//   - on_dirty: Called when a region of an element is marked as dirty and needs to be redrawn. The application will want to
//     invalidate the container window to trigger an operating system redraw. Set this with dred_gui_set_global_on_dirty().
//   - on_capture_mouse: Called when the mouse is captured and gives the application the opportunity to capture the mouse against
//     the container window at the operating system level. Set with dred_gui_set_global_on_capture_mouse().
//   - on_release_mouse: Called when the mouse is released. The opposite of on_capture_mouse.
//   - on_capture_keyboard: Called when an element is given the keyboard focus and gives the application the opportunity to
//     apply the keyboard focus to the container window. Set with dred_gui_set_global_on_capture_keyboard().
//   - on_release_keyboard: Called when an element loses the keyboard focus. The opposite of on_capture_keyboard.
//   - on_change_cursor: Called when the current cursor needs to be changed as a result of the mouse moving over a new element.
//
// Layout
// - An element's data structure does not store it's relative position but instead stores it's absolute position. The rationale
//   for this is that storing it as relative complicates absolute positioning calculations because it would need to do a recursive
//   traversal of the element's ancestors.
// - Child elements can be scaled by setting an element's inner scale. The inner scale does not scale the element itself - only
//   it's children.
// - When an element is drawn, everything is scaled by it's inner scale. For example, if the inner scale is 2x and a 100x100 quad
//   is drawn, the quad will be scaled to 200x200. An exception to this rule is fonts, which are never scaled. This 0s because
//   text is always drawn based on the size of the font.
// - Applications should only need to work on unscaled coordinates. That is, an application should never need to worry about
//   manual scaling, except for fonts. When positioning and sizing child elements, they should be done based on unscaled
//   coordinates.
// - Use the inner scale system for DPI awareness.
// - The inner scale is applied recursively. That is, if a top level element has it's inner scale set to 2x and one of it's
//   children has an inner scale of 2x, the actual inner scale of the child element will be 4x.
//
//
// Drawing/Painting
// - Drawing is one of the more complex parts of the GUI because it can be a bit unintuitive regarding exactly when an element
//   is drawn and when a drawing function is allowed to be called.
// - To draw an element, call dred_control_draw(). This takes a pointer to the element to draw and the rectangle region that should
//   be redrawn. Any children that fall inside the specified rectangle region will be redrawn as well. You do not want to call
//   dred_control_draw() on a parent element and then again on it's children because dr_gui will do that automatically.
// - dred_control_draw() does not draw anything directly, but rather calls painting callback routines which is where the actual
//   drawing takes place.
// - Sometimes an application will need to be told when a region of an element is dirty and needs redrawing. An example is
//   event-driven, non real-time applications such as normal desktop applications. To mark an element as dirty, you call the
//   dred_control_dirty() function which takes the element that is dirty, and the rectangle region that needs to be redrawn. This
//   does not redraw the element immediately, but instead posts an on_dirty event for the application. Marking regions as dirty
//   is not strictly required, but you should prefer it for event-driven applications that require painting operations to be
//   performed at specific times (such as inside Win32's WM_PAINT messages).
// - Some operations will cause a region of an element to become dirty - such as when it is resized. dr_gui will
//   automatically mark the relevant regions as dirty which in turn will cause a paint message to be posted. If this is not
//   required, it can be disabled with dred_gui_disable_auto_dirty(). You may want to disable automatic dirtying if you are
//   running a real-time application like a game which would redraw the entire GUI every frame anyway and thus not require
//   handling of the paint message.
// - Real-time application guidelines (games, etc.):
//   - dred_gui_disable_auto_dirty()
//   - dred_control_draw(pTopLevelControl, 0, 0, viewportWidth, viewportHeight) at the end of every frame after your main loop.


//
// EXAMPLES
//
// Basic Drawing:
//
// dred_control_draw(pTopLevelControl, 0, 0, dred_control_get_width(pTopLevelControl), dred_control_get_height(pTopLevelControl));
//
// -------------------------
//
// Event-Driven Drawing (Win32):
//
// void my_global_on_dirty_win32(dred_control* pControl, dred_rect relativeRect) {
//     dred_rect absoluteRect = relativeRect;
//     dred_make_rect_absolute(pControl, &absoluteRect);
//
//     RECT rect;
//     rect.left   = absoluteRect.left;
//     rect.top    = absoluteRect.top;
//     rect.right  = absoluteRect.right;
//     rect.height = absoluteRect.bottom;
//     InvalidateRect((HWND)dred_control_get_user_data(dred_control_find_top_level_control(pControl)), &rect, FALSE);
// }
//
// ...
//
// LRESULT CALLBACK MyWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
//     ...
//     dred_control* pTopLevelControl = (dred_control*)GetWindowLongPtr(hWnd, 0);
//     if (pTopLevelControl != NULL) {
//         switch (msg) {
//             ...
//             case WM_PAINT:
//             {
//                 RECT rect;
//                 if (GetUpdateRect(hWnd, &rect, FALSE)) {
//                     dred_control_draw(pTopLevelControl, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
//                 }
//
//                 break;
//             }
//             ...
//         }
//     }
//     ...
// }
//

#ifndef DRED_MAX_FONT_FAMILY_LENGTH
#define DRED_MAX_FONT_FAMILY_LENGTH  128
#endif

typedef struct dred_gui dred_gui;
typedef struct dred_control dred_control;
typedef struct dred_rect dred_rect;
typedef struct dred_gui_painting_callbacks dred_gui_painting_callbacks;
typedef struct dred_gui_font dred_gui_font;
typedef struct dred_gui_image dred_gui_image;


// Casts a pointer to any structure to a dred_control*. Note that this will only work if the dred_control object
// is at the first byte of the structure.
#define DRED_CONTROL(a) ((dred_control*)(a))

/// Structure representing a rectangle.
struct dred_rect
{
    float left;
    float top;
    float right;
    float bottom;
};

typedef struct
{
    dtk_color bgColor;
    dtk_color fgColor;
    dtk_font* pFont;
} dred_text_style;

typedef struct
{
    /// The destination position on the x axis. This is ignored if the DR2D_IMAGE_ALIGN_CENTER option is set.
    float dstX;

    /// The destination position on the y axis. This is ignored if the DR2D_IMAGE_ALIGN_CENTER option is set.
    float dstY;

    /// The destination width.
    float dstWidth;

    /// The destination height.
    float dstHeight;


    /// The source offset on the x axis.
    float srcX;

    /// The source offset on the y axis.
    float srcY;

    /// The source width.
    float srcWidth;

    /// The source height.
    float srcHeight;


    /// The position of the destination's bounds on the x axis.
    float dstBoundsX;

    /// The position of the destination's bounds on the y axis.
    float dstBoundsY;

    /// The width of the destination's bounds.
    float dstBoundsWidth;

    /// The height of the destination's bounds.
    float dstBoundsHeight;


    /// The foreground tint color. This is not applied to the background color, and the alpha component is ignored.
    dtk_color foregroundTint;

    /// The background color. Only used if the DR2D_IMAGE_DRAW_BACKGROUND option is set.
    dtk_color backgroundColor;

    /// The bounds color. This color is used for the region of the bounds that sit on the outside of the destination rectangle. This will
    /// usually be set to the same value as backgroundColor, but it could also be used to draw a border around the image.
    dtk_color boundsColor;


    /// Flags for controlling how the image should be drawn.
    unsigned int options;

} dred_gui_draw_image_args;


#define DRED_GUI_IMAGE_DRAW_BOUNDS         (1 << 2)
#define DRED_GUI_IMAGE_CLIP_BOUNDS         (1 << 3)        //< Clips the image to the bounds
#define DRED_GUI_IMAGE_ALIGN_CENTER        (1 << 4)

#define DRED_GUI_READ                      (1 << 0)
#define DRED_GUI_WRITE                     (1 << 1)

#define DRED_GUI_FONT_NO_CLEARTYPE         (1 << 0)


typedef void (* dred_gui_on_move_proc)                 (dred_control* pControl, float newRelativePosX, float newRelativePosY);
typedef void (* dred_gui_on_size_proc)                 (dred_control* pControl, float newWidth, float newHeight);
typedef void (* dred_gui_on_mouse_enter_proc)          (dred_control* pControl);
typedef void (* dred_gui_on_mouse_leave_proc)          (dred_control* pControl);
typedef void (* dred_gui_on_mouse_move_proc)           (dred_control* pControl, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_mouse_button_down_proc)    (dred_control* pControl, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_mouse_button_up_proc)      (dred_control* pControl, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_mouse_button_dblclick_proc)(dred_control* pControl, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_mouse_wheel_proc)          (dred_control* pControl, int delta, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_key_down_proc)             (dred_control* pControl, dtk_key key, int stateFlags);
typedef void (* dred_gui_on_key_up_proc)               (dred_control* pControl, dtk_key key, int stateFlags);
typedef void (* dred_gui_on_printable_key_down_proc)   (dred_control* pControl, unsigned int character, int stateFlags);
typedef void (* dred_gui_on_paint_proc)                (dred_control* pControl, dred_rect relativeRect, dtk_surface* pSurface);
typedef void (* dred_gui_on_dirty_proc)                (dred_control* pControl, dred_rect relativeRect);
typedef dtk_bool32 (* dred_gui_on_hittest_proc)              (dred_control* pControl, float relativePosX, float relativePosY);
typedef void (* dred_gui_on_capture_mouse_proc)        (dred_control* pControl);
typedef void (* dred_gui_on_release_mouse_proc)        (dred_control* pControl);
typedef void (* dred_gui_on_capture_keyboard_proc)     (dred_control* pControl, dtk_control* pPrevCapturedControl);
typedef void (* dred_gui_on_release_keyboard_proc)     (dred_control* pControl, dtk_control* pNewCapturedControl);
typedef void (* dred_gui_on_change_cursor_proc)        (dred_control* pControl, dtk_system_cursor_type cursor);
typedef void (* dred_gui_on_delete_element_proc)       (dred_control* pControl);
typedef void (* dred_gui_on_log)                       (dred_gui* pGUI, const char* message);

typedef void (* dred_gui_set_clip_proc)                     (dred_rect relativeRect, dtk_surface* pSurface);
typedef void (* dred_gui_get_clip_proc)                     (dred_rect* pRectOut, dtk_surface* pSurface);
typedef void (* dred_gui_draw_line_proc)                    (float startX, float startY, float endX, float endY, float width, dtk_color color, dtk_surface* pSurface);
typedef void (* dred_gui_draw_rect_proc)                    (dred_rect relativeRect, dtk_color color, dtk_surface* pSurface);
typedef void (* dred_gui_draw_rect_outline_proc)            (dred_rect relativeRect, dtk_color color, float outlineWidth, dtk_surface* pSurface);
typedef void (* dred_gui_draw_rect_with_outline_proc)       (dred_rect relativeRect, dtk_color color, float outlineWidth, dtk_color outlineColor, dtk_surface* pSurface);
typedef void (* dred_gui_draw_round_rect_proc)              (dred_rect relativeRect, dtk_color color, float radius, dtk_surface* pSurface);
typedef void (* dred_gui_draw_round_rect_outline_proc)      (dred_rect relativeRect, dtk_color color, float radius, float outlineWidth, dtk_surface* pSurface);
typedef void (* dred_gui_draw_round_rect_with_outline_proc) (dred_rect relativeRect, dtk_color color, float radius, float outlineWidth, dtk_color outlineColor, dtk_surface* pSurface);
typedef void (* dred_gui_draw_text_proc)                    (dtk_font* pFont, float scale, const char* text, int textLengthInBytes, float posX, float posY, dtk_color color, dtk_color backgroundColor, dtk_surface* pSurface);
typedef void (* dred_gui_draw_image_proc)                   (dtk_surface* pImage, dtk_draw_surface_args* pArgs, dtk_surface* pSurface);

typedef dtk_font* (* dred_gui_create_font_proc)                        (dtk_context* pTK, const char* family, unsigned int size, dtk_font_weight weight, dtk_font_slant slant, unsigned int flags);
typedef void              (* dred_gui_delete_font_proc)                        (dtk_font* pFont);
typedef unsigned int      (* dred_gui_get_font_size_proc)                      (dtk_font* pFont);
typedef dtk_bool32              (* dred_gui_get_font_metrics_proc)                   (dtk_font* pFont, float scale, dtk_font_metrics* pMetricsOut);
typedef dtk_bool32              (* dred_gui_get_glyph_metrics_proc)                  (dtk_font* pFont, float scale, unsigned int utf32, dtk_glyph_metrics* pMetricsOut);
typedef dtk_bool32              (* dred_gui_measure_string_proc)                     (dtk_font* pFont, float scale, const char* text, size_t textSizeInBytes, dtk_int32* pWidthOut, dtk_int32* pHeightOut);
typedef dtk_bool32              (* dred_gui_get_text_cursor_position_from_point_proc)(dtk_font* pFont, float scale, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float* pTextCursorPosXOut, size_t* pCharacterIndexOut);
typedef dtk_bool32              (* dred_gui_get_text_cursor_position_from_char_proc) (dtk_font* pFont, float scale, const char* text, size_t characterIndex, float* pTextCursorPosXOut);

typedef dtk_surface*     (* dred_gui_create_image_proc)            (dtk_context* pTK, unsigned int width, unsigned int height, unsigned int stride, const void* pImageData);
typedef void                  (* dred_gui_delete_image_proc)            (dtk_surface* pImage);
typedef void                  (* dred_gui_get_image_size_proc)          (dtk_surface* pImage, unsigned int* pWidthOut, unsigned int* pHeightOut);

typedef dtk_bool32 (* dred_gui_visible_iteration_proc)(dred_control* pControl, dred_rect *pRelativeRect, void* pUserData);

// Structure containing callbacks for painting routines.
struct dred_gui_painting_callbacks
{
    dred_gui_set_clip_proc                            setClip;
    dred_gui_get_clip_proc                            getClip;

    dred_gui_draw_rect_proc                           drawRect;
    dred_gui_draw_rect_outline_proc                   drawRectOutline;
    dred_gui_draw_rect_with_outline_proc              drawRectWithOutline;
    dred_gui_draw_round_rect_proc                     drawRoundRect;
    dred_gui_draw_round_rect_outline_proc             drawRoundRectOutline;
    dred_gui_draw_round_rect_with_outline_proc        drawRoundRectWithOutline;
    dred_gui_draw_text_proc                           drawText;
    dred_gui_draw_image_proc                          drawImage;

    dred_gui_create_font_proc                         createFont;
    dred_gui_delete_font_proc                         deleteFont;
    //dred_gui_get_font_size_proc                       getFontSize;
    dred_gui_get_font_metrics_proc                    getFontMetrics;
    dred_gui_get_glyph_metrics_proc                   getGlyphMetrics;
    dred_gui_measure_string_proc                      measureString;
    dred_gui_get_text_cursor_position_from_point_proc getTextCursorPositionFromPoint;
    dred_gui_get_text_cursor_position_from_char_proc  getTextCursorPositionFromChar;

    dred_gui_create_image_proc                        createImage;
    dred_gui_delete_image_proc                        deleteImage;
    dred_gui_get_image_size_proc                      getImageSize;
};

struct dred_gui_image
{
    /// A pointer to the context that owns this image.
    dred_gui* pGUI;

    /// The resource handle that is passed around to the callback functions.
    dtk_surface* pInternalImage;
};

struct dred_gui_font
{
    /// A pointer to the context that owns this font.
    dred_gui* pGUI;

    /// The font family.
    char family[DRED_MAX_FONT_FAMILY_LENGTH];

    /// The base size of the font. This is set to the value that was used to create the font in the first place.
    unsigned int size;

    /// The font's weight.
    dtk_font_weight weight;

    /// The fon't slant.
    dtk_font_slant slant;

    /// The font's flags. Can be a combination of the following:
    ///   DRED_GUI_FONT_NO_CLEARTYPE
    unsigned int flags;

    /// The internal font. This is created by the rendering backend.
    dtk_font* pInternalFont;
};


struct dred_control
{
    // The base DTK control.
    dtk_control baseControl;

    /// A pointer to the context that owns this element. This should never be null for valid elements.
    dred_gui* pGUI;


    /// A pointer to the parent element. This can be null in which case this element is the parent.
    //dred_control* pParent;

    /// A pointer to the first child element.
    //dred_control* pFirstChild;

    /// A pointer to the last child element.
    //dred_control* pLastChild;

    /// A pointer to the next sibling element.
    //dred_control* pNextSibling;

    /// A pointer ot the previous sibing element.
    //dred_control* pPrevSibling;


    /// The type of the element, as a string. This is only every used by the host application, and is intended to be used as way
    /// to selectively perform certain operations on specific types of GUI elements.
    char type[64];


    /// The absolute position of the element on the x axis. A position of 0 is the left side of the surface it is attached to.
    //float absolutePosX;

    /// The absolute position of the element on the y axis. A position of 0 is the top of the surface it is attached to.
    //float absolutePosY;

    /// The width of the element.
    //float width;

    /// The height of the element.
    //float height;


    /// The cursor. Defaults to drge_cursor_default.
    //dtk_system_cursor_type cursor;

    /// Boolean flags.
    //unsigned int flags;

    // The region of the element that's dirty.
    //dred_rect dirtyRect;


    /// The function to call when the element's relative position moves.
    dred_gui_on_move_proc onMove;

    /// The function to call when the element's size changes.
    dred_gui_on_size_proc onSize;

    /// The function to call when the mouse enters the given element.
    dred_gui_on_mouse_enter_proc onMouseEnter;

    /// The function to call when the mouse leaves the given element.
    dred_gui_on_mouse_leave_proc onMouseLeave;

    /// The function to call when the mouse is moved while over the element.
    dred_gui_on_mouse_move_proc onMouseMove;

    /// The function to call when a mouse buttonis pressed while over the element.
    dred_gui_on_mouse_button_down_proc onMouseButtonDown;

    /// The function to call when a mouse button is released while over the element.
    dred_gui_on_mouse_button_up_proc onMouseButtonUp;

    /// The function to call when a mouse button is double-clicked while over the element.
    dred_gui_on_mouse_button_dblclick_proc onMouseButtonDblClick;

    /// The function to call when the mouse wheel it turned while over the element.
    dred_gui_on_mouse_wheel_proc onMouseWheel;

    /// The function to call when a key on the keyboard is pressed or auto-repeated.
    dred_gui_on_key_down_proc onKeyDown;

    /// The function to call when a key on the keyboard is released.
    dred_gui_on_key_up_proc onKeyUp;

    /// The function to call when a printable character is pressed or auto-repeated. This would be used for text editing.
    dred_gui_on_printable_key_down_proc onPrintableKeyDown;

    /// The function to call when the paint event is received.
    dred_gui_on_paint_proc onPaint;

    /// The function to call when the element is marked as dirty.
    dred_gui_on_dirty_proc onDirty;

    /// The function to call when a hit test needs to be performed.
    dred_gui_on_hittest_proc onHitTest;

    /// The event handler to call when an element receives the mouse focus.
    dred_gui_on_capture_mouse_proc onCaptureMouse;

    /// The event handler to call when an element loses the mouse focus.
    dred_gui_on_release_mouse_proc onReleaseMouse;

    /// The event handler to call when an element receives the keyboard focus.
    dred_gui_on_capture_keyboard_proc onCaptureKeyboard;

    /// The event handler to call when an element loses the keyboard focus.
    dred_gui_on_release_keyboard_proc onReleaseKeyboard;


    // Application-defined data.
    //void* pUserData;
};

struct dred_gui
{
    // The dred context that owns the GUI system.
    dred_context* pDred;

    /// The painting callbacks.
    dred_gui_painting_callbacks paintingCallbacks;


    /// The inbound event counter. This is incremented with dred_gui__begin_inbound_event() and decremented with
    /// dred_gui__end_inbound_event(). We use this to determine whether or not an inbound event is being processed.
    //int inboundEventCounter;

    /// The outbound event counter that we use as the "lock" for outbound events. All outbound events are posted from
    /// inbound events, and all inbound events are already synchronized so we don't need to use a mutex. This is mainly
    /// used as a way to check for erroneous outbound event generation.
    //int outboundEventLockCounter;

    /// A pointer to the element that is sitting directly under the mouse. This is updated on every inbound mouse move event
    /// and is used for determining when a mouse enter/leave event needs to be posted.
    //dred_control* pControlUnderMouse;

    /// A pointer to the element with the mouse capture.
    //dred_control* pControlWithMouseCapture;

    /// A pointer to the element with the keyboard focus.
    //dred_control* pControlWithKeyboardCapture;

    /// A pointer to the element that wants the keyboard focus. If for some reason an element isn't able to immediately
    /// capture the keyboard (such as while in the middle of a release_keyboard event handler) this will be set to that
    /// particular element. This will then be used to capture the keyboard at a later time when it is able.
    //dred_control* pControlWantingKeyboardCapture;

    /// The current cursor.
    //dtk_system_cursor_type currentCursor;

    /// Boolean flags.
    //unsigned int flags;


    /// The global event callback to call when an element is marked as dirty.
    //dred_gui_on_dirty_proc onGlobalDirty;

    /// The global event handler to call when an element captures the mouse.
    //dred_gui_on_capture_mouse_proc onGlobalCaptureMouse;

    /// The global event handler to call when an element releases the mouse.
    //dred_gui_on_release_mouse_proc onGlobalReleaseMouse;

    /// The global event handler to call when an element captures the keyboard.
    //dred_gui_on_capture_keyboard_proc onGlobalCaptureKeyboard;

    /// The global event handler to call when an element releases the keyboard.
    //dred_gui_on_release_keyboard_proc onGlobalReleaseKeyboard;

    /// The global event handler to call when the system cursor needs to change.
    //dred_gui_on_change_cursor_proc onChangeCursor;

    /// The function to call when an element is deleted.
    dred_gui_on_delete_element_proc onDeleteControl;


    /// The function to call when a log message is posted.
    dred_gui_on_log onLog;



    /// A pointer to the top level element that was passed in from the last inbound mouse move event.
    //dred_control* pLastMouseMoveTopLevelControl;

    /// The position of the mouse that was passed in from the last inbound mouse move event.
    //float lastMouseMovePosX;
    //float lastMouseMovePosY;


    // A pointer to the list of dirty elements.
    //dred_control** ppDirtyControls;

    // The size of the buffer containing the dirty elements.
    //size_t dirtyControlBufferSize;

    // The number of dirty top-level elements.
    //size_t dirtyControlCount;

    /// The counter to use when determining whether or not an on_dirty event needs to be posted. This is incremented with
    /// dred_control__begin_auto_dirty() and decremented with dred_control__end_auto_dirty(). When the counter is decremented and hits
    /// zero, the on_dirty event will be posted.
    //unsigned int dirtyCounter;
};



/////////////////////////////////////////////////////////////////
//
// CORE API
//
/////////////////////////////////////////////////////////////////

// Initializes a GUI context.
dtk_bool32 dred_gui_init(dred_gui* pGUI, dred_context* pDred);

/// Deletes a context and everything that it created.
void dred_gui_uninit(dred_gui* pGUI);



/////////////////////////////////////////////////////////////////
// Events

/// Posts a mouse leave inbound event.
///
/// @remarks
///     The intention behind this event is to allow the application to let dr_gui know that the mouse have left the window. Since dr_gui does
///     not have any notion of a window it must rely on the host application to notify it.
//void dred_gui_post_inbound_event_mouse_leave(dred_control* pTopLevelControl);
//
///// Posts a mouse move inbound event.
//void dred_gui_post_inbound_event_mouse_move(dred_control* pTopLevelControl, int mousePosX, int mousePosY, int stateFlags);
//
///// Posts a mouse button down inbound event.
//void dred_gui_post_inbound_event_mouse_button_down(dred_control* pTopLevelControl, int mouseButton, int mousePosX, int mousePosY, int stateFlags);
//
///// Posts a mouse button up inbound event.
//void dred_gui_post_inbound_event_mouse_button_up(dred_control* pTopLevelControl, int mouseButton, int mousePosX, int mousePosY, int stateFlags);
//
///// Posts a mouse button double-clicked inbound event.
//void dred_gui_post_inbound_event_mouse_button_dblclick(dred_control* pTopLevelControl, int mouseButton, int mousePosX, int mousePosY, int stateFlags);
//
///// Posts a mouse wheel inbound event.
//void dred_gui_post_inbound_event_mouse_wheel(dred_control* pTopLevelControl, int mouseButton, int mousePosX, int mousePosY, int stateFlags);
//
///// Posts a key down inbound event.
//void dred_gui_post_inbound_event_key_down(dred_gui* pGUI, dtk_key key, int stateFlags);
//
///// Posts a key up inbound event.
//void dred_gui_post_inbound_event_key_up(dred_gui* pGUI, dtk_key key, int stateFlags);
//
///// Posts a printable key down inbound event.
/////
///// @remarks
/////     The \c character argument should be a UTF-32 code point.
//void dred_gui_post_inbound_event_printable_key_down(dred_gui* pGUI, unsigned int character, int stateFlags);


/// Registers the global on_dirty event callback.
///
/// @remarks
///     This is called whenever a region of an element is marked as dirty and allows an application to mark the region of the
///     container window as dirty to trigger an operating system level repaint of the window.
//void dred_gui_set_global_on_dirty(dred_gui* pGUI, dred_gui_on_dirty_proc onDirty);

/// Registers the global on_capture_mouse event callback.
///
/// @remarks
///     This is called whenever an element receives an the mouse capture and allows an application to do operating system level
///     mouse captures against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
//void dred_gui_set_global_on_capture_mouse(dred_gui* pGUI, dred_gui_on_capture_mouse_proc onCaptureMouse);

/// Registers the global on_release_mouse event callback.
///
/// @remarks
///     This is called whenever an element loses an the mouse capture and allows an application to do operating system level
///     mouse releases against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
//void dred_gui_set_global_on_release_mouse(dred_gui* pGUI, dred_gui_on_release_mouse_proc onReleaseMouse);

/// Registers the global on_capture_keyboard event callback.
///
/// @remarks
///     This is called whenever an element receives an the keyboard capture and allows an application to do an operating system level
///     keyboard focus against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
//void dred_gui_set_global_on_capture_keyboard(dred_gui* pGUI, dred_gui_on_capture_keyboard_proc onCaptureKeyboard);

/// Registers the global on_release_keyboard event callback.
///
/// @remarks
///     This is called whenever an element loses an the keyboard capture and allows an application to do an operating system level
///     keyboard release against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
//void dred_gui_set_global_on_release_keyboard(dred_gui* pGUI, dred_gui_on_capture_keyboard_proc onReleaseKeyboard);

/// Sets the global on_change_cursor event callback.
///
/// @remarks
///     This is called whenever the operating system needs to change the cursor.
//void dred_gui_set_global_on_change_cursor(dred_gui* pGUI, dred_gui_on_change_cursor_proc onChangeCursor);

/// Sets the function to call when an element is deleted.
void dred_gui_set_on_delete_element(dred_gui* pGUI, dred_gui_on_delete_element_proc onDeleteControl);


/// Registers the callback to call when a log message is posted.
void dred_gui_set_on_log(dred_gui* pGUI, dred_gui_on_log onLog);




/////////////////////////////////////////////////////////////////
// Controls

// The default event handler for dred_control's.
dtk_bool32 dred_control_event_handler(dtk_event* pEvent);

/// Creates an element.
dtk_bool32 dred_control_init(dred_control* pControl, dred_context* pDred, dred_control* pParent, dtk_control* pDTKParent, const char* type, dtk_event_proc onEvent);

/// Deletes and element.
void dred_control_uninit(dred_control* pControl);


// Retrieves the dred context that owns the given control.
dred_context* dred_control_get_context(dred_control* pControl);

// Retrieves the GUI context that owns the given control.
dred_gui* dred_control_get_gui(dred_control* pControl);



/// Sets the type of the element.
///
/// The type name cannot be more than 63 characters in length.
dtk_bool32 dred_control_set_type(dred_control* pControl, const char* type);

/// Retrieves the type fo the element.
const char* dred_control_get_type(dred_control* pControl);

/// Determines whether or not the given element is of the given type.
dtk_bool32 dred_control_is_of_type(dred_control* pControl, const char* type);
dtk_bool32 dred_is_control_type_of_type(const char* type, const char* base);


/// Hides the given element.
void dred_control_hide(dred_control *pControl);

/// Shows the given element.
void dred_control_show(dred_control* pControl);

/// Determines whether or not the element is marked as visible.
///
/// @remarks
///     This is a direct accessor for the internal visible flag of the element and is not recursive. Thus, if this element is
///     marked as visible, but it's parent is invisible, it will still return DTK_TRUE. Use dred_control_is_visible_recursive() to do
///     a recursive visibility check.
dtk_bool32 dred_control_is_visible(const dred_control* pControl);

/// Recursively determines whether or not the element is marked as visible.
dtk_bool32 dred_control_is_visible_recursive(const dred_control* pControl);


/// Disables clipping against the parent for the given element.
void dred_control_disable_clipping(dred_control* pControl);

/// Enables clipping against the parent for the given element.
void dred_control_enable_clipping(dred_control* pControl);

/// Determines whether or not clipping is enabled for the given element.
dtk_bool32 dred_control_is_clipping_enabled(const dred_control* pControl);


/// Sets the element that should receive all future mouse related events.
///
/// @remarks
///     Release the mouse capture with dred_gui_release_mouse().
void dred_gui_capture_mouse(dred_control* pControl);
void dred_control_capture_mouse(dred_control* pControl) { dred_gui_capture_mouse(pControl); }

/// Releases the mouse capture.
void dred_gui_release_mouse(dred_gui* pGUI);

/// Releases the mouse capture without posting the local-scoped event.
//void dred_gui_release_mouse_no_local_notify(dred_gui* pGUI);

/// Releases the mouse capture without posting the global-scoped event. Should only be used in very specific cases, usually in combination with awkward interop with the window system.
//void dred_gui_release_mouse_no_global_notify(dred_gui* pGUI);

/// Retrieves a pointer to the element with the mouse capture.
//dred_control* dred_gui_get_element_with_mouse_capture(dred_gui* pGUI);

/// Determines whether or not the given element has the mouse capture.
//dtk_bool32 dred_control_has_mouse_capture(dred_control* pControl);


/// Sets the element that should receive all future keyboard related events.
///
/// @remarks
///     Releases the keyboard capture with dred_gui_release_keyboard().
void dred_gui_capture_keyboard(dred_control* pControl);
void dred_control_capture_keyboard(dred_control* pControl) { dred_gui_capture_keyboard(pControl); }

/// Releases the keyboard capture.
void dred_gui_release_keyboard(dred_gui* pGUI);

/// Releases the keyboard capture without posting the global-scoped event.
//void dred_gui_release_keyboard_no_local_notify(dred_gui* pGUI);

/// Releases the keyboard capture without posting the global-scoped event. Should only be used in very specific cases, usually in combination with awkward interop with the window system.
//void dred_gui_release_keyboard_no_global_notify(dred_gui* pGUI);

/// Retrieves a pointer to the element with the keyboard capture.
//dred_control* dred_gui_get_element_with_keyboard_capture(dred_gui* pGUI);

/// Determines whether or not the given element has the keyboard capture.
//dtk_bool32 dred_control_has_keyboard_capture(dred_control* pControl);


/// Sets the cursor to use when the mouse enters the given GUI element.
void dred_control_set_cursor(dred_control* pControl, dtk_system_cursor_type cursor);

/// Retrieves the cursor to use when the mouse enters the given GUI element.
dtk_system_cursor_type dred_control_get_cursor(dred_control* pControl);

// Helper function for showing a popup menu relative to the given control.
void dred_control_show_popup_menu(dred_control* pControl, dtk_menu* pMenu, int relativePosX, int relativePosY);


//// Events ////

/// Registers the on_move event callback.
void dred_control_set_on_move(dred_control* pControl, dred_gui_on_move_proc callback);

/// Registers the on_size event callback.
void dred_control_set_on_size(dred_control* pControl, dred_gui_on_size_proc callback);

/// Registers the on_mouse_enter event callback.
void dred_control_set_on_mouse_enter(dred_control* pControl, dred_gui_on_mouse_enter_proc callback);

/// Registers the on_mouse_leave event callback.
void dred_control_set_on_mouse_leave(dred_control* pControl, dred_gui_on_mouse_leave_proc callback);

/// Registers the on_mouse_move event callback.
void dred_control_set_on_mouse_move(dred_control* pControl, dred_gui_on_mouse_move_proc callback);

/// Registers the on_mouse_button_down event callback.
void dred_control_set_on_mouse_button_down(dred_control* pControl, dred_gui_on_mouse_button_down_proc callback);

/// Registers the on_mouse_button_up event callback.
void dred_control_set_on_mouse_button_up(dred_control* pControl, dred_gui_on_mouse_button_up_proc callback);

/// Registers the on_mouse_button_down event callback.
void dred_control_set_on_mouse_button_dblclick(dred_control* pControl, dred_gui_on_mouse_button_dblclick_proc callback);

/// Registers the on_mouse_wheel event callback.
void dred_control_set_on_mouse_wheel(dred_control* pControl, dred_gui_on_mouse_wheel_proc callback);

/// Registers the on_key_down event callback.
void dred_control_set_on_key_down(dred_control* pControl, dred_gui_on_key_down_proc callback);

/// Registers the on_key_up event callback.
void dred_control_set_on_key_up(dred_control* pControl, dred_gui_on_key_up_proc callback);

/// Registers the on_printable_key_down event callback.
void dred_control_set_on_printable_key_down(dred_control* pControl, dred_gui_on_printable_key_down_proc callback);

/// Registers the on_paint event callback.
void dred_control_set_on_paint(dred_control* pControl, dred_gui_on_paint_proc callback);

/// Registers the on_dirty event callback.
void dred_control_set_on_dirty(dred_control* pControl, dred_gui_on_dirty_proc callback);

/// Registers the on_hittest event callback.
void dred_control_set_on_hittest(dred_control* pControl, dred_gui_on_hittest_proc callback);

/// Registers the on_capture_mouse event callback.
void dred_control_set_on_capture_mouse(dred_control* pControl, dred_gui_on_capture_mouse_proc callback);

/// Registers the on_release_mouse event callback.
void dred_control_set_on_release_mouse(dred_control* pControl, dred_gui_on_release_mouse_proc callback);

/// Registers the on_capture_keyboard event callback.
void dred_control_set_on_capture_keyboard(dred_control* pControl, dred_gui_on_capture_keyboard_proc callback);

/// Registers the on_release_keyboard event callback.
void dred_control_set_on_release_keyboard(dred_control* pControl, dred_gui_on_release_keyboard_proc callback);



//// Containment and Hit Detection ////

/// Determines whether or not the given point is inside the bounds of the given element.
///
/// @remarks
///     This only checks if the point is inside the bounds of the element and does not take hit testing into account. This difference
///     with this one and dred_control_is_point_inside() is that the latter will use hit testing.
dtk_bool32 dred_control_is_point_inside_bounds(const dred_control* pControl, float absolutePosX, float absolutePosY);

/// Determines whether or not the given point is inside the given element.
///
/// @remarks
///     This will use hit testing to determine whether or not the point is inside the element.
dtk_bool32 dred_control_is_point_inside(dred_control* pControl, float absolutePosX, float absolutePosY);

/// Finds the element under the given point taking mouse pass-through and hit testing into account.
//dtk_control* dred_gui_find_control_under_point(dred_control* pTopLevelControl, float absolutePosX, float absolutePosY);

/// Determines whether or not the given element is currently sitting directly under the mouse.
dtk_bool32 dred_control_is_under_mouse(dred_control* pTopLevelControl);



//// Hierarchy ////

// Retrieves the parent of the given element.
//dred_control* dtk_control_get_parent(dred_control* pChildControl);

/// Detaches the given element from it's parent.
void dred_control_detach(dred_control* pChildControl);

/// Attaches the given element as a child of the given parent element, and appends it to the end of the children list.
void dred_control_append(dred_control* pChildControl, dred_control* pParentControl);

/// Attaches the given element as a child of the given parent element, and prepends it to the end of the children list.
void dred_control_prepend(dred_control* pChildControl, dred_control* pParentControl);

/// Appends the given element to the given sibling.
void dred_control_append_sibling(dred_control* pControlToAppend, dred_control* pControlToAppendTo);

/// Prepends the given element to the given sibling.
void dred_control_prepend_sibling(dred_control* pControlToPrepend, dred_control* pControlToPrependTo);

/// Retrieves a pointer to the given element's top-level ancestor.
///
/// @remarks
///     If pControl is the top level element, the return value will be pControl.
dtk_control* dred_control_find_top_level_control(dred_control* pControl);

/// Determines whether or not the given element is the parent of the other.
///
/// @remarks
///     This is not recursive. Use dred_control_is_ancestor() to do a recursive traversal.
dtk_bool32 dred_control_is_parent(dred_control* pParentControl, dred_control* pChildControl);

/// Determines whether or not the given element is a child of the other.
///
/// @remarks
///     This is not recursive. Use dred_control_is_descendant() to do a recursive traversal.
dtk_bool32 dred_control_is_child(dred_control* pChildControl, dred_control* pParentControl);

/// Determines whether or not the given element is an ancestor of the other.
dtk_bool32 dred_control_is_ancestor(dred_control* pAncestorControl, dred_control* pChildControl);

/// Determines whether or not the given element is a descendant of the other.
dtk_bool32 dred_control_is_descendant(dred_control* pChildControl, dred_control* pAncestorControl);

/// Determines whether or not the given element is itself or a descendant.
dtk_bool32 dred_control_is_self_or_ancestor(dred_control* pAncestorControl, dred_control* pChildControl);

/// Determines whether or not the given element is itself or a descendant.
dtk_bool32 dred_control_is_self_or_descendant(dred_control* pChildControl, dred_control* pAncestorControl);



//// Layout ////

/// Sets the absolute position of the given element.
void dred_control_set_absolute_position(dred_control* pControl, float positionX, float positionY);

/// Retrieves the absolute position of the given element.
void dred_control_get_absolute_position(const dred_control* pControl, float* positionXOut, float* positionYOut);
float dred_control_get_absolute_position_x(const dred_control* pControl);
float dred_control_get_absolute_position_y(const dred_control* pControl);


/// Sets the relative position of the given element.
void dred_control_set_relative_position(dred_control* pControl, float relativePosX, float relativePosY);

/// Retrieves the relative position of the given element.
void dred_control_get_relative_position(const dred_control* pControl, float* relativePosXOut, float* relativePosYOut);
float dred_control_get_relative_position_x(const dred_control* pControl);
float dred_control_get_relative_position_y(const dred_control* pControl);


/// Sets the size of the given element.
void dred_control_set_size(dred_control* pControl, float width, float height);

/// Retrieves the size of the given element.
void dred_control_get_size(const dred_control* pControl, float* widthOut, float* heightOut);
float dred_control_get_width(const dred_control* pControl);
float dred_control_get_height(const dred_control* pControl);



/// Retrieves the absolute rectangle for the given element.
dred_rect dred_control_get_absolute_rect(const dred_control* pControl);

/// Retrieves the relative rectangle for the given element.
dred_rect dred_control_get_relative_rect(const dred_control* pControl);

/// Retrieves the local rectangle for the given element.
///
/// @remarks
///     The local rectangle is equivalent to dred_make_rect(0, 0, dred_control_get_width(pControl), dred_control_get_height(pControl));
dred_rect dred_control_get_local_rect(const dred_control* pControl);



//// Painting ////

/// Registers the custom painting callbacks.
///
/// @remarks
///     This can only be called once, so it should always be done after initialization. This will fail if called
///     more than once.
dtk_bool32 dred_gui_register_painting_callbacks(dred_gui* pGUI, dred_gui_painting_callbacks callbacks);


/// Performs a recursive traversal of all visible elements in the given rectangle.
///
/// @param pParentControl [in] A pointer to the element to iterate.
///
/// @remarks
///     pParentControl will be included in the iteration is it is within the rectangle.
///     @par
///     The rectangle should be relative to pParentControl.
///     @par
///     The iteration callback function takes a pointer to a rectangle structure that represents the visible portion of the
///     element. This pointer can be modified by the callback to create an adjusted rectangle which can be used for clipping.
//dtk_bool32 dred_control_iterate_visible_elements(dred_control* pParentControl, dred_rect relativeRect, dred_gui_visible_iteration_proc callback, void* pUserData);


/// Disable's automatic dirtying of elements.
//void dred_gui_disable_auto_dirty(dred_gui* pGUI);

/// Enable's automatic dirtying of elements.
//void dred_gui_enable_auto_dirty(dred_gui* pGUI);

/// Determines whether or not automatic dirtying is enabled.
//dtk_bool32 dred_gui_is_auto_dirty_enabled(dred_gui* pGUI);


/// Begins accumulating a dirty rectangle.
///
/// Returns a pointer to the top level element that was made dirty.
//dred_control* dred_control_begin_dirty(dred_control* pControl);

/// Ends accumulating a dirty rectangle, and requests a redraw from the backend if the counter reaches zero.
//void dred_control_end_dirty(dred_control* pControl);

/// Marks a region of the given element as dirty.
///
/// @remarks
///     This will not redraw the element immediately, but instead post a paint event.
//void dred_control_dirty(dred_control* pControl, dred_rect relativeRect);


/// Draws the given element.
///
/// @remarks
///     Do not call this on one element, then again on it's children. Any children that fall inside the specified
///     rectangle will also be redrawn.
///     @par
///     This will call painting event handlers which will give the application time to do custom drawing.
///     @par
///     When using easy_draw to do drawing, pPaintData must be set to a pointer to the relevant easydraw_surface object.
//void dred_control_draw(dred_control* pControl, dred_rect relativeRect, dtk_surface* pSurface);

/// Retrieves the current clipping rectangle.
void dred_control_get_clip(dred_control* pControl, dred_rect* pRelativeRect, dtk_surface* pSurface);

/// Sets the clipping rectangle to apply to all future draw operations on this element.
void dred_control_set_clip(dred_control* pControl, dred_rect relativeRect, dtk_surface* pSurface);

/// Draws a rectangle on the given element.
void dred_control_draw_rect(dred_control* pControl, dred_rect relativeRect, dtk_color color, dtk_surface* pSurface);

/// Draws the outline of a rectangle on the given element.
void dred_control_draw_rect_outline(dred_control* pControl, dred_rect relativeRect, dtk_color color, float outlineWidth, dtk_surface* pSurface);

/// Draws a filled rectangle with an outline on the given element.
void dred_control_draw_rect_with_outline(dred_control* pControl, dred_rect relativeRect, dtk_color color, float outlineWidth, dtk_color outlineColor, dtk_surface* pSurface);

/// Draws a rectangle with rounded corners on the given element.
void dred_control_draw_round_rect(dred_control* pControl, dred_rect relativeRect, dtk_color color, float radius, dtk_surface* pSurface);

/// Draws the outline of a rectangle with rounded corners on the given element.
void dred_control_draw_round_rect_outline(dred_control* pControl, dred_rect relativeRect, dtk_color color, float radius, float outlineWidth, dtk_surface* pSurface);

/// Draws a filled rectangle and it's outline with rounded corners on the given element.
void dred_control_draw_round_rect_with_outline(dred_control* pControl, dred_rect relativeRect, dtk_color color, float radius, float outlineWidth, dtk_color outlineColor, dtk_surface* pSurface);

/// Draws a run of text on the given element.
///
/// @remarks
///     This does not do any complex formatting like multiple lines and whatnot. Complex formatting can be achieved with multiple
///     calls to this function.
///     @par
///     \c textSizeInBytes can be -1 in which case the text string is treated as null terminated.
void dred_control_draw_text(dred_control* pControl, dtk_font* pFont, float scale, const char* text, int textLengthInBytes, float posX, float posY, dtk_color color, dtk_color backgroundColor, dtk_surface* pSurface);

/// Draws an image.
void dred_control_draw_image(dred_control* pControl, dred_gui_image* pImage, dred_gui_draw_image_args* pArgs, dtk_surface* pSurface);


/// Creates a font resource.
dred_gui_font* dred_gui_create_font(dred_gui* pGUI, const char* family, unsigned int size, dtk_font_weight weight, dtk_font_slant slant, unsigned int flags);

/// Deletes a font resource.
void dred_gui_delete_font(dred_gui_font* pFont);

/// Retrieves the metrics of the given font.
dtk_bool32 dred_gui_get_font_metrics(dred_gui_font* pFont, float scale, dtk_font_metrics* pMetricsOut);

/// Retrieves the metrics of the glyph for the given character when rendered with the given font.
dtk_bool32 dred_gui_get_glyph_metrics(dred_gui_font* pFont, float scale, unsigned int utf32, dtk_glyph_metrics* pMetricsOut);

/// Retrieves the dimensions of the given string when drawn with the given font.
///
/// @remarks
///     When the length of the text is 0, the width will be set to 0 and the height will be set to the line height.
dtk_bool32 dred_gui_measure_string(dred_gui_font* pFont, float scale, const char* text, size_t textLengthInBytes, dtk_int32* pWidthOut, dtk_int32* pHeightOut);

/// Retrieves the position to place a text cursor based on the given point for the given string when drawn with the given font.
dtk_bool32 dred_gui_get_text_cursor_position_from_point(dred_gui_font* pFont, float scale, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float* pTextCursorPosXOut, size_t* pCharacterIndexOut);

/// Retrieves the position to palce a text cursor based on the character at the given index for the given string when drawn with the given font.
dtk_bool32 dred_gui_get_text_cursor_position_from_char(dred_gui_font* pFont, float scale, const char* text, size_t characterIndex, float* pTextCursorPosXOut);



/// Creates an image that can be passed to dred_control_draw_image().
///
/// @remarks
///     The dimensions and format of an image are immutable. If these need to change, then the image needs to be deleted and re-created.
///     @par
///     If pData is NULL, the default image data is undefined.
///     @par
///     If stride is set to 0, it is assumed to be tightly packed.
dred_gui_image* dred_gui_create_image(dred_gui* pGUI, unsigned int width, unsigned int height, unsigned int stride, const void* pData);

/// Deletes the given image.
void dred_gui_delete_image(dred_gui_image* pImage);

/// Retrieves the size of the given image.
void dred_gui_get_image_size(dred_gui_image* pImage, unsigned int* pWidthOut, unsigned int* pHeightOut);



/////////////////////////////////////////////////////////////////
//
// HIGH-LEVEL API
//
/////////////////////////////////////////////////////////////////

//// Hit Testing and Layout ////

/// An on_size event callback that resizes every child element to that of the parent.
void dred_control_on_size_fit_children_to_parent(dred_control* pControl, float newWidth, float newHeight);

/// An on_hit_test event callback that can be used to always fail the mouse hit test.
dtk_bool32 dred_control_pass_through_hit_test(dred_control* pControl, float mousePosX, float mousePosY);


//// Painting ////

/// Draws a border around the given element.
void dred_control_draw_border(dred_control* pControl, float borderWidth, dtk_color color, dtk_surface* pSurface);



/////////////////////////////////////////////////////////////////
//
// UTILITY API
//
/////////////////////////////////////////////////////////////////

/// Creates a color object from a set of RGBA color components.
dtk_color dred_rgba(uint8_t r, uint8_t g, uint8_t b, uint8_t a);

/// Creates a color object from a set of RGB color components.
dtk_color dred_rgb(uint8_t r, uint8_t g, uint8_t b);

/// Clamps the given rectangle to another.
dred_rect dred_clamp_rect(dred_rect rect, dred_rect other);

/// Clamps the given rectangle to the given element and returns whether or not any of it is contained within the element's rectangle.
dtk_bool32 dred_clamp_rect_to_element(const dred_control* pControl, dred_rect* pRelativeRect);

/// Converts the given rectangle from absolute to relative to the given element.
dred_rect dred_make_rect_relative(const dred_control* pControl, dred_rect* pRect);

/// Converts the given rectangle from relative to absolute based on the given element.
dred_rect dred_make_rect_absolute(const dred_control* pControl, dred_rect* pRect);

/// Converts the given point from absolute to relative to the given element.
void dred_make_point_relative(const dred_control* pControl, float* positionX, float* positionY);

/// Converts the given point from relative to absolute based on the given element.
void dred_make_point_absolute(const dred_control* pControl, float* positionX, float* positionY);

/// Creates a dred_rect object.
dred_rect dred_make_rect(float left, float top, float right, float bottom);

/// Creates an inside-out rectangle.
///
/// @remarks
///     An inside our rectangle is a negative-dimension rectangle with each edge at the extreme edges. The left edge will be at the
///     right-most side and the right edge will be at the left-most side. The same applies for the top and bottom edges.
dred_rect dred_make_inside_out_rect();

/// Expands the given rectangle on all sides by the given amount.
///
/// @remarks
///     This will increase the width and height of the rectangle by <amount> x 2.
///     @par
///     The growth amount can be negative, in which case it will be shrunk. Note that this does not do any checking to ensure the rectangle
///     contains positive dimensions after a shrink.
dred_rect dred_grow_rect(dred_rect rect, float amount);

/// Scales the given rectangle.
///
/// @param scaleX [in] The scale to apply to <left> and <right>
/// @param scaleY [in] The scale to apply to <top> and <bottom>
///
/// @remarks
///     This will modify the <left> and <top> properties which means the rectangle will change position. To adjust only the size, scale the
///     rectangle manually.
dred_rect dred_scale_rect(dred_rect rect, float scaleX, float scaleY);

/// Offsets the given rectangle.
dred_rect dred_offset_rect(dred_rect rect, float offsetX, float offsetY);

/// Creates a rectangle that contains both of the given rectangles.
dred_rect dred_rect_union(dred_rect rect0, dred_rect rect1);

/// Determines whether or not the given rectangle contains the given point.
///
/// @remarks
///     An important not here is that if the position is sitting on the right or bottom border, DTK_FALSE will be returned. If, however, the point
///     is sitting on the left or top border, DTK_TRUE will be returned. The reason for this is that elements may sit exactly side-by-side with
///     each other, and if we use this function to determine if a point is contained within an element (which we do), we would end up having
///     this return DTK_TRUE for both elements, which we don't want.
dtk_bool32 dred_rect_contains_point(dred_rect rect, float posX, float posY);

/// Determines whether or not two rectangles are equal.
dtk_bool32 dred_rect_equal(dred_rect rect0, dred_rect rect1);

/// Determines whether or not the given rectangle has any volume (width and height > 0).
dtk_bool32 dred_rect_has_volume(dred_rect rect);



/////////////////////////////////////////////////////////////////
//
// DTK Interop.
//
/////////////////////////////////////////////////////////////////

// A covenience function for creating a new context and registering the DTK painting callbacks.
//
// @remarks
//     This is equivalent to dred_gui_init() followed by dred_gui_register_dtk_callbacks().
dtk_bool32 dred_gui_init_dtk(dred_gui* pGUI, dred_context* pDred);

// Registers the drawing callbacks for use with DTK.
//
// @remarks
//     The user data of each callback is assumed to be a pointer to a dtk_surface object.
void dred_gui_register_dtk_callbacks(dred_gui* pGUI);

